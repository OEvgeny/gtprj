<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - materials - dynamic cube reflection</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        background-color: #000000;
        margin: 0px;
        overflow: hidden;
      }

      #info {
        position: absolute
        top: 0px; width: 100%;
        color: #ffffff;
        padding: 5px;
        font-family:Monospace;
        font-size:13px;
        font-weight: bold;
        text-align:center;
      }

      a {
        color: #ffffff;
      }
    </style>
  </head>
  <body>
    <div style="position: absolute; z-index:10; bottom: 0; left:0; right: 0; color: white; text-align: center; cursor: default;"><span> Press C to toggle normal direction. <br> Original demo by Matyushichev Constantine <br>&copy; 2015 by Olonov Evgeniy. <a href="https://github.com/OEvgeny/gtprj">GitHub</a></span></div>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.js"></script>
    <script>
      //Global scope variables
      var camera, scene, renderer, mouse = {}
      var cube, cubeRotation = new THREE.Vector3(0,0,0)
      
      window.cube = cube

      var fov = 45,
      isUserInteracting = false,
      onMouseDownMouseX = 0, onMouseDownMouseY = 0,
      lon = 0, onMouseDownLon = 0,
      lat = 0, onMouseDownLat = 0,
      phi = 0, theta = 0


      var path = 'textures/',
        format = '.png',
        roomFiles = [
          path + 'x_minus' + format, path + 'x_plus' + format,
          path + 'y_plus' + format, path + 'y_minus' + format,
          path + 'z_plus' + format, path + 'z_minus' + format,
        ],
        cubeNormalFile = path + 'normal.png',
        cubeDiffuseFile = path + 'diffuse.jpg'
        //cubeDispFile = path + 'dice_dispmap.png'

      var roomTexture = THREE.ImageUtils.loadTextureCube(
        roomFiles, 
        new THREE.UVMapping(), 
        function () {
          init()
          animate()
        }
      )

      function init() {

        camera = new THREE.PerspectiveCamera( fov, window.innerWidth / window.innerHeight, 1, 1000 )

        scene = new THREE.Scene()

        var ambientLight = new THREE.AmbientLight(0x222222)
        scene.add(ambientLight);
        var lightsPos = [
          {x: -200, z: -200},
          {x: -200, z: 0, distance: 320},
          {x: -200, z: 200},
          {x: 200, z: -200},
          {x: 200, z: 0, distance: 320},
          {x: 200, z: 200},
          {x: 0, z: 0, distance: 250}
        ]
        for (var i = 0; i < lightsPos.length; i++) {
          var light = new THREE.PointLight(0xeef7ff)
          light.position.y = 130
          light.position.x = lightsPos[i].x
          light.position.z = lightsPos[i].z
          light.distance = lightsPos[i].distance || 420
          scene.add(light)
        }

        var roomShader = THREE.ShaderLib["cube"]
        roomShader.uniforms[ "tCube" ].value = roomTexture

        var roomMaterial = new THREE.ShaderMaterial({
          fragmentShader: roomShader.fragmentShader,
          vertexShader: roomShader.vertexShader,
          uniforms: roomShader.uniforms,
          depthWrite: false,
          side: THREE.BackSide
        }),
        roomMesh = new THREE.Mesh(new THREE.BoxGeometry(500, 500, 500), roomMaterial)

        scene.add(roomMesh)

        var cubeShader = THREE.ShaderLib["normalmap"]
        cubeShader.uniforms["enableAO"].value = false
        cubeShader.uniforms["enableDiffuse"].value = true
        cubeShader.uniforms["enableSpecular"].value = false
        cubeShader.uniforms["enableReflection"].value = true
        //cubeShader.uniforms["enableDisplacement"].value = false
        cubeShader.uniforms[ "uNormalScale" ].value.y = -1
        cubeShader.uniforms[ "reflectivity" ].value = 0.01
        cubeShader.uniforms[ "shininess" ].value = 200
        cubeShader.uniforms["tNormal"].value = THREE.ImageUtils.loadTexture(cubeNormalFile)
        cubeShader.uniforms["tDiffuse"].value = THREE.ImageUtils.loadTexture(cubeDiffuseFile)
        //cubeShader.uniforms["tDisplacement"].value = THREE.ImageUtils.loadTexture(cubeDispFile)
        cubeShader.uniforms[ "tCube" ].value = roomTexture;
        cubeShader.uniforms["diffuse"].value = new THREE.Color(1, 1, 1)
        //cubeShader.uniforms[ "uDisplacementBias" ].value = -1.428408;
        //cubeShader.uniforms[ "uDisplacementScale" ].value = 22.436143;

        window.cubeShader = cubeShader

        var cubeMaterial = new THREE.ShaderMaterial({
          fragmentShader: cubeShader.fragmentShader,
          vertexShader: cubeShader.vertexShader,
          uniforms: cubeShader.uniforms,
          lights: true,
          fog: false
        }),
        cubeMesh = new THREE.Mesh(new THREE.BoxGeometry(30,30,30), cubeMaterial)
        
        var stepu = 1.0 / 3, stepv = 1.0 / 2
        for (var i = 0, k = 0; i < 3; i++) {
          for (var j = 0; j < 2; j++) {
            var u = i * 1.0 / 3 , v = j * 1.0 / 2 
            
            cubeMesh.geometry.faceVertexUvs[0][k++] = [
              new THREE.Vector2(u, v + stepv),
              new THREE.Vector2(u, v),
              new THREE.Vector2(u + stepu, v + stepv)
            ]
  
            cubeMesh.geometry.faceVertexUvs[0][k++] = [
              new THREE.Vector2(u, v),
              new THREE.Vector2(u + stepu, v),
              new THREE.Vector2(u + stepu, v + stepv)
            ]
               
          }
        }
        cubeMesh.geometry.uvsNeedUpdate = true
        cubeMesh.geometry.computeTangents()
        //No need to use negative w for cube (works incorrect for normalmap shader)
        cubeMesh.geometry.faces.forEach(function(face) {
          face.vertexTangents.forEach(function(vector) {
            if (vector.w < 0.0) {
              vector.w *= -1
              vector.x *= -1
              vector.y *= -1
              vector.z *= -1
            }
        })})
        cubeMesh.geometry.tangentsNeedUpdate = true

        cube = cubeMesh
        scene.add(cubeMesh)

        renderer = new THREE.WebGLRenderer({antialias: true})
        renderer.setSize( window.innerWidth, window.innerHeight)

        document.body.appendChild(renderer.domElement)
        document.addEventListener('mousedown', onDocumentMouseDown, false)
        document.addEventListener('touchstart', onDocumentMouseDown)
        document.addEventListener('mousewheel', onDocumentMouseWheel, false)
        document.addEventListener('DOMMouseScroll', onDocumentMouseWheel, false)
        window.addEventListener( 'resize', onWindowResized, false)
        window.addEventListener("keypress", function(e) {
          if (e.keyIdentifier === 'U+0043') //C
            cubeShader.uniforms[ "uNormalScale" ].value.y *= -1
        })
        onWindowResized( null )
      }

      function onWindowResized(event) {
        renderer.setSize( window.innerWidth, window.innerHeight )
        camera.projectionMatrix.makePerspective( fov, window.innerWidth / window.innerHeight, 1, 1100)
      }

      function onDocumentClick(event) {
        var mouse = {x: event.x, y:event.y}

        if (event instanceof TouchEvent) {
          if (event.touches.length > 1)
            return
          mouse = {x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY}
        }

        event.preventDefault()
      }

      function onDocumentMouseDown(event) {
        mouseDownStart = event.timeStamp
        event.preventDefault()

        if (event instanceof TouchEvent) {
          if (event.touches.length > 1) {
            return
          }
          onPointerDownPointerX = event.changedTouches[0].clientX
          onPointerDownPointerY = event.changedTouches[0].clientY
        } else {
          onPointerDownPointerX = event.clientX
          onPointerDownPointerY = event.clientY
        }

        onPointerDownLon = lon
        onPointerDownLat = lat

        document.addEventListener('mousemove', onDocumentMouseMove, false)
        document.addEventListener('mouseup', onDocumentMouseUp, false)
        document.addEventListener('touchmove', onDocumentMouseMove, false)
        document.addEventListener('touchend', onDocumentMouseUp, false)
      }

      function onDocumentMouseMove(event) {
        if (event instanceof TouchEvent) {
          if (event.touches.length > 1)
            return
          lon = ( event.changedTouches[0].clientX - onPointerDownPointerX ) * 0.1 + onPointerDownLon
          lat = ( event.changedTouches[0].clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat
        } else {
          lon = ( event.clientX - onPointerDownPointerX ) * 0.1 + onPointerDownLon
          lat = ( event.clientY - onPointerDownPointerY ) * 0.1 + onPointerDownLat
        }
      }

      function onDocumentMouseUp(event) {
        if (event.timeStamp - mouseDownStart < 160) {
            onDocumentClick(event)
        }
        document.removeEventListener('mousemove', onDocumentMouseMove, false )
        document.removeEventListener('mouseup', onDocumentMouseUp, false )
        document.removeEventListener('touchmove', onDocumentMouseMove, false)
        document.removeEventListener('touchend', onDocumentMouseUp, false)
      }

      function onDocumentMouseWheel(event) {
        // WebKit
        if ( event.wheelDeltaY ) {
          fov -= event.wheelDeltaY * 0.05
        // Opera / Explorer 9
        } else if ( event.wheelDelta ) {
          fov -= event.wheelDelta * 0.05
        // Firefox
        } else if ( event.detail ) {
          fov += event.detail * 1.0
        }

        camera.projectionMatrix.makePerspective( fov, window.innerWidth / window.innerHeight, 1, 1100 )
      }

      function animate() {
        requestAnimationFrame( animate )
        render()
      }

      function render() {
        var time = Date.now()

        lon += .15

        lat = Math.max(-85, Math.min(85, lat))
        phi = THREE.Math.degToRad(90 - lat)
        theta = THREE.Math.degToRad(lon)

        cube.rotation.z = - 4 * Math.cos(phi)
        cube.rotation.y = - 4 * Math.sin(phi) * Math.sin(theta) 
        cube.rotation.x = - 4 * Math.cos(phi)

        camera.position.x = 100 * Math.sin(phi) * Math.cos(theta)
        camera.position.y = 100 * Math.cos(phi)
        camera.position.z = 100 * Math.sin(phi) * Math.sin(theta)

        camera.lookAt(scene.position)

        renderer.render(scene, camera)
      }
    </script>
  </body>
</html>
